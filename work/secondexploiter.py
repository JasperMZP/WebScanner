'''
    WASec – a software that performs automated tests on websites and scan them for SQL Injection and Cross-site Scripting Vulnerabilites.
    Copyright (c) 2018, Inass Husien.

    WASec is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation, either version 2 of the License or (at your option) any later version.

    This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along with this program.
    If not, see <http://www.gnu.org/licenses/>

    You can contact us at e.ismail@it.misuratau.edu.ly
'''
import io
from PyQt5 import QtWidgets
from beyondlogin import BeyondLogin
from formhandler import FormHandler
from urllib import parse
from time import sleep
from datetime import datetime as dt, timedelta as td
from PyQt5.QtCore import QObject, pyqtSignal
from robobrowser import browser  # Helps generating requests for webpages
from requests import exceptions
from datetime import datetime, timedelta


class SecondExploiter(QObject):
    current = pyqtSignal(str)
    tested = pyqtSignal(int)
    update_tsp = pyqtSignal(int)
    finish = pyqtSignal(dict)

    def __init__(self, info, bases, instance, parent=None):
        super(SecondExploiter, self).__init__(parent)
        self._pages_to_exploit = info['links']
        self._pages_to_exploit_cp = info['links']
        self.exploited = {}  # filled like this: [[index, url, type, successful_payload]]
        self.count = 0
        self.total = info['total_crawled']
        self.window = instance
        self.info = bases
        if self.info['logged_in']:
            self._logged_in = False
        else:
            self._logged_in = True
        self._dynamic_urls = info['dynamic']
        self._dynamic_urls_cp = info['dynamic']
        self._elapsed = 0
        self.delay = 15
        self._requests = 0
        self.forms = []
        self._browser = browser.RoboBrowser(history=True, parser="html.parser", user_agent="WASecBot")
        self._browser.session.verify = False
        self.faults = []
        self.current.connect(self.window.lbltargetsql2.setText)
        self.tested.connect(self._show_tested)
        self.update_tsp.connect(self.window.pbsqltotal2.setValue)
        self.finish.connect(self.window.after_sqli2)
        self.tested.emit(0)
        self.window.btnsqlcancel2.clicked.connect(self.pause)
        self.finished = False
        self.running = True
        self.second_order = {}
        self.second_order_url = []
        self.second_order_index = 0

    def _compute_crawl_delay(self):
        self._requests += 1
        if self._requests <= 10:
            self._elapsed += self._browser.response.elapsed.total_seconds()
            delay = self._elapsed / self._requests
            self.delay = delay * 200
            if self.delay >= 180:
                self.delay = 15
        else:
            self._requests = 1
            self._elapsed = self._browser.response.elapsed.total_seconds()
            self.delay = self._elapsed * 200

    def _opener(self, url):
        retry = 0
        while True:
            try:
                self._browser.open(url)
                break
            except exceptions.ConnectionError as ce:
                # sleep(self.delay * retry)
                if retry == 10:
                    return False
                else:
                    retry += 1
        return True

    def pause(self):
        self.running = False
        choice = QtWidgets.QMessageBox.question(self.window, "Cancel Testing!",
                                                "WASec is not finished yet, are you sure you want to stop testing?",
                                                QtWidgets.QMessageBox.Cancel | QtWidgets.QMessageBox.Yes)
        if choice == QtWidgets.QMessageBox.Yes:
            self.finished = True
            self.run()
        else:
            self.running = True

    def _show_current(self, url):
        self.window.lbltargetsql2.setText(url)

    def _show_tested(self, no):
        self.window.lblsqltot2.setText(str(no) + " vulnerabilities")

    def _update_total(self, value):
        self.window.pbsqltotal2.setValue(value)

    def _login(self):
        if self.info['logged_in']:
            handel = BeyondLogin(self._browser)
            self._logged_in = handel.get_login_info(self.info)
        else:
            self._logged_in = True

    def _is_listed(self, url):
        for index in self.exploited:
            if self.exploited[index]['url'] == url:
                return True
        return False

    def _is_form_tested(self, test_form, url, method):
        found = False
        for form in self.forms:
            if form[0] != url and form[1] == test_form.parsed and form[2] == method:
                found = True
                break
        if not found:
            self.forms.append([url, test_form.parsed, method])
        return found

    def _error_based_get(self, page_link):
        self._opener(page_link)
        self._compute_crawl_delay()
        original_page = self._browser.parsed

        attacks_file = io.open("sqli-error-based.txt", "r", encoding='UTF-8')
        parsed_url = parse.urlparse(page_link)
        query_params = parsed_url.query.split("&")

        for payload in attacks_file:
            new_query = '&'.join(["{}{}".format(param, payload) for param in query_params])
            #  replace old query values with injection values
            parsed_url = parsed_url._replace(query=new_query)
            #  add new generated url to list of injected urls
            injected = parse.urlunparse(parsed_url)
            self.window.lblsqltot.setText("Pausing for " + str(round(self.delay, 2)) + " seconds...");
            # sleep(self.delay)
            self.tested.emit(self.count)
            self._opener(injected)
            self._compute_crawl_delay()
            if '200' in str(self._browser.response):
                response_page = self._browser.parsed
                exploited = (str(response_page).find('error in your SQL syntax') != -1) or (
                        str(response_page).find('error in your MySQL syntax') != -1)
                if exploited and (original_page != response_page) and (not self._is_listed(page_link)):
                    self.exploited[self.count] = {'url': page_link, 'type': "error-based-get", 'payload': payload}
                    self.count += 1
                    return True
        return False

    def _time_based_get(self, page_link):
        self.window.lblsqltot.setText("Pausing for " + str(self.delay) + " seconds...");
        # sleep(self.delay)
        self.tested.emit(self.count)
        self._opener(page_link)
        self._compute_crawl_delay()

        attacks_file = io.open("sqli-time-based.txt", "r")
        parsed_url = parse.urlparse(page_link)
        query_params = parsed_url.query.split("&")

        for payload in attacks_file:
            position1 = str.lower(payload).find('sleep(')
            if position1 != -1:
                position1 = position1 + 6  # length of 'sleep(' = 6 characters
                position2 = str.lower(payload).find(')', position1)
                sleep_time = int(payload[position1:position2])
            else:
                continue
            new_query = '&'.join(["{}{}".format(param, payload) for param in query_params])
            #  replace old query values with injection values
            parsed_url = parsed_url._replace(query=new_query)
            #  add new generated url to list of injected urls
            injected = parse.urlunparse(parsed_url)
            self.window.lblsqltot.setText("Pausing for " + str(self.delay) + " seconds...");
            # sleep(self.delay)
            self.tested.emit(self.count)
            t1 = dt.now().time()
            tt1 = td(seconds=t1.second, microseconds=t1.microsecond, minutes=t1.minute, hours=t1.hour)
            self._opener(injected)
            self._compute_crawl_delay()
            t2 = dt.now().time()
            tt2 = td(seconds=t2.second, microseconds=t2.microsecond, minutes=t2.minute, hours=t2.hour)
            time_taken = tt2 - tt1
            if 200 == self._browser.response.status_code:
                if time_taken.total_seconds() >= sleep_time and (not self._is_listed(page_link)):
                    self.exploited[self.count] = {'url': page_link, 'type': "time-based-get", 'payload': payload}
                    self.count += 1
                    return True
        return False

    def _second_get(self, page_link):
        self._opener(page_link)
        self._compute_crawl_delay()
        original_page = self._browser.parsed

        parsed_url = parse.urlparse(page_link)
        query_params = parsed_url.query.split("&")

        payload = "sodA" + str(self.second_order_index) + 'sodB'

        new_query = '&'.join(["{}{}".format(param, payload) for param in query_params])
        #  replace old query values with injection values
        parsed_url = parsed_url._replace(query=new_query)
        #  add new generated url to list of injected urls
        injected = parse.urlunparse(parsed_url)
        self.window.lblsqltot.setText("Pausing for " + str(round(self.delay, 2)) + " seconds...");
        # sleep(self.delay)
        self.tested.emit(self.count)
        self._opener(injected)
        self._compute_crawl_delay()
        if '200' in str(self._browser.response):
            response_page = self._browser.parsed

    def _handel_dynamics_second(self, url):
        result = self._second_get(url)
        self.second_order_url.append(url)
        self.second_order_index += 1
        if result:
            return True
        return False

    def _handel_dynamics(self, url):
        result = self._error_based_get(url)
        if result:
            return True
        # result = self._time_based_get(url)
        # if result:
        #     return True
        # result = self._bool_based_get(url)
        # if result:
        #     return True
        # return False

    def _second_post(self, form, fields, page_link):
        payload = "sodA" + str(self.second_order_index) + 'sodB'
        page = self._browser.parsed
        for attack_field in fields.attack_fields:
            form[attack_field].value = payload

        for box_name in fields.checkboxes:
            # tick checkboxes by assigning their values to them
            form[box_name].value = fields.checkboxes.get(box_name)
            # e.g. <input type='checkbox' name='mycheck' value='ticked'>
            ## fields.checkboxs.get(box_name) ===> ['ticked']
            ## form['mycheck'].value = ['ticked']
            # now, box is ticked

        for radio_name in fields.radios:
            form[radio_name].value = fields.radios.get(radio_name)
            # same as in checkboxes
        # TODO
        for select in fields.selects:
            form[select].value = fields.selects.get(select)

        for field in fields.other_fields:
            if 'textarea' in field:
                name = fields.other_fields[field]['name']
                form[name] = "some text"
            elif 'email' in field:
                name = fields.other_fields[field]['name']
                form[name] = "soso5220@gmail.com"
            elif field == 'csrf-token':
                name = fields.other_fields[field]['name']
                value = fields.other_fields[field]['value']
                form[name].value = value

        for submit in fields.submit_buttons:  # in case of multiple submits
            if submit != 'NA' and submit.name not in form.submit_fields.keys():
                form.add_field(submit)

            retry = 0
            while True:
                try:
                    if submit == 'NA':
                        self._browser.submit_form(form)
                    else:
                        self._browser.submit_form(form, submit=submit)
                    self._compute_crawl_delay()
                    break
                except exceptions.ConnectionError as ce:
                    # sleep(self.delay * retry)
                    if retry == 10:
                        return False
                    else:
                        retry += 1
            # response_url = str(self._browser.url)
            response_page = self._browser.parsed

            self.window.lblsqltot.setText("Pausing for " + str(self.delay) + " seconds...");
            # sleep(self.delay)
            self.tested.emit(self.count)

    def _time_based_post(self, form, fields, page_link):
        attacks_file = io.open("sqli-time-based.txt", "r")
        for payload in attacks_file:
            position1 = str.lower(payload).find('sleep(')
            if position1 != -1:
                position1 = position1 + 6  # length of 'sleep(' = 6 characters
                position2 = str.lower(payload).find(')', position1)
                sleep_time = int(payload[position1:position2])
            else:
                continue
            for attack_field in fields.attack_fields:
                form[attack_field].value = payload

            for box_name in fields.checkboxes:
                # tick checkboxes by assigning their values to them
                form[box_name].value = fields.checkboxes.get(box_name)
                # e.g. <input type='checkbox' name='mycheck' value='ticked'>
                ## fields.checkboxs.get(box_name) ===> ['ticked']
                ## form['mycheck'].value = ['ticked']
                # now, box is ticked

            for radio_name in fields.radios:
                form[radio_name].value = fields.radios.get(radio_name)
                # same as in checkboxes

            for field in fields.other_fields:
                if 'textarea' in field:
                    name = fields.other_fields[field]['name']
                    form[name] = "some text"
                elif 'email' in field:
                    name = fields.other_fields[field]['name']
                    form[name] = "soso5220@gmail.com"
                elif field == 'csrf-token':
                    name = fields.other_fields[field]['name']
                    value = fields.other_fields[field]['value']
                    form[name].value = value

            for submit in fields.submit_buttons:  # in case of multiple submits
                if submit != 'NA' and submit.name not in form.submit_fields.keys():
                    form.add_field(submit)

                retry = 0
                while True:
                    try:
                        if submit == 'NA':
                            self._browser.submit_form(form)
                        else:
                            self._browser.submit_form(form, submit=submit)
                        self._compute_crawl_delay()
                        break
                    except exceptions.ConnectionError as ce:
                        # sleep(self.delay * retry)
                        if retry == 10:
                            return False
                        else:
                            retry += 1

                for rspLink in self.second_order[page_link]:
                    t1 = dt.now().time()
                    tt1 = td(seconds=t1.second, microseconds=t1.microsecond, minutes=t1.minute, hours=t1.hour)
                    self._opener(rspLink)
                    self._compute_crawl_delay()
                    if '200' in str(self._browser.response):
                        t2 = dt.now().time()
                        tt2 = td(seconds=t2.second, microseconds=t2.microsecond, minutes=t2.minute, hours=t2.hour)
                        time_taken = tt2 - tt1
                        if time_taken.total_seconds() >= sleep_time:
                            self.exploited[self.count] = {'url': page_link, 'type': "second-order-time-based-post",
                                                          'payload': payload}
                            self.count += 1
                            return True
                        self.window.lblsqltot.setText("Pausing for " + str(self.delay) + " seconds...");
                        # sleep(self.delay)
                        self.tested.emit(self.count)
        return False

    def _error_based_post(self, form, fields, page_link):
        error_attacks = io.open("sqli-error-based.txt", "r", encoding='UTF-8')
        for payload in error_attacks:
            page = self._browser.parsed
            for attack_field in fields.attack_fields:
                form[attack_field].value = payload

            for box_name in fields.checkboxes:
                # tick checkboxes by assigning their values to them
                form[box_name].value = fields.checkboxes.get(box_name)

            for radio_name in fields.radios:
                form[radio_name].value = fields.radios.get(radio_name)
                # same as in checkboxes
            # TODO
            for select in fields.selects:
                form[select].value = fields.selects.get(select)

            for field in fields.other_fields:
                if 'textarea' in field:
                    name = fields.other_fields[field]['name']
                    form[name] = "some text"
                elif 'email' in field:
                    name = fields.other_fields[field]['name']
                    form[name] = "soso5220@gmail.com"
                elif field == 'csrf-token':
                    name = fields.other_fields[field]['name']
                    value = fields.other_fields[field]['value']
                    form[name].value = value

            for submit in fields.submit_buttons:  # in case of multiple submits
                if submit != 'NA' and submit.name not in form.submit_fields.keys():
                    form.add_field(submit)

                retry = 0
                while True:
                    try:
                        if submit == 'NA':
                            self._browser.submit_form(form)
                        else:
                            self._browser.submit_form(form, submit=submit)
                        self._compute_crawl_delay()
                        break
                    except exceptions.ConnectionError as ce:
                        # sleep(self.delay * retry)
                        if retry == 10:
                            return False
                        else:
                            retry += 1
                # response_url = str(self._browser.url)
                if page_link =="http://localhost:801/sqli-labs-master/Less-24/new_user.php":
                    response_page = self._browser.parsed
                    print(str(response_page))


                for rspLink in self.second_order[page_link]:
                    self._opener(rspLink)
                    self._compute_crawl_delay()
                    if '200' in str(self._browser.response):
                        response_page = str(self._browser.parsed)
                        exploited = (str(response_page).find('error in your SQL syntax') != -1) or (
                                str(response_page).find('error in your MySQL syntax') != -1)
                        if exploited and (page != response_page) and (not self._is_listed(page_link)):
                            self.exploited[self.count] = {'url': page_link + " ==> " + rspLink,
                                                          'type': "second-order-error-based-post",
                                                          'payload': payload}
                            self.count += 1
                            print("危险2")
                            return True
                        self.window.lblsqltot.setText("Pausing for " + str(self.delay) + " seconds...");
                        # sleep(self.delay)
                        self.tested.emit(self.count)
        return False

    def _error_based_post_Http_header(self, form, fields, page_link):
        error_attacks = io.open("sqli-header-error-based.txt", "r", encoding='UTF-8')
        for payload in error_attacks:
            page = self._browser.parsed
            self._browser.session.headers['User-Agent'] = payload.strip()
            self._browser.session.headers['Referer'] = payload.strip()
            for attack_field in fields.attack_fields:
                form[attack_field].value = payload

            for box_name in fields.checkboxes:
                # tick checkboxes by assigning their values to them
                form[box_name].value = fields.checkboxes.get(box_name)
                # e.g. <input type='checkbox' name='mycheck' value='ticked'>
                ## fields.checkboxs.get(box_name) ===> ['ticked']
                ## form['mycheck'].value = ['ticked']
                # now, box is ticked

            for radio_name in fields.radios:
                form[radio_name].value = fields.radios.get(radio_name)
                # same as in checkboxes
            # TODO
            for select in fields.selects:
                form[select].value = fields.selects.get(select)

            for field in fields.other_fields:
                if 'textarea' in field:
                    name = fields.other_fields[field]['name']
                    form[name] = "some text"
                elif 'email' in field:
                    name = fields.other_fields[field]['name']
                    form[name] = "soso5220@gmail.com"
                elif field == 'csrf-token':
                    name = fields.other_fields[field]['name']
                    value = fields.other_fields[field]['value']
                    form[name].value = value

            for submit in fields.submit_buttons:  # in case of multiple submits
                if submit != 'NA' and submit.name not in form.submit_fields.keys():
                    form.add_field(submit)

                retry = 0
                while True:
                    try:
                        if submit == 'NA':
                            self._browser.submit_form(form)
                        else:
                            self._browser.submit_form(form, submit=submit)
                        self._compute_crawl_delay()
                        break
                    except exceptions.ConnectionError as ce:
                        # sleep(self.delay * retry)
                        if retry == 10:
                            return False
                        else:
                            retry += 1
                # response_url = str(self._browser.url)
                response_page = self._browser.parsed
                exploited = (str(response_page).find('error in your SQL syntax') != -1) or (
                        str(response_page).find('error in your MySQL syntax') != -1)
                if exploited and (page != response_page) and (not self._is_listed(page_link)):
                    self.exploited[self.count] = {'url': page_link, 'type': "error-based-post(http-header)",
                                                  'payload': payload}
                    self.count += 1
                    return True
                self.window.lblsqltot.setText("Pausing for " + str(self.delay) + " seconds...");
                # sleep(self.delay)
                self.tested.emit(self.count)
        return False

    def _error_based_get_cookie(self, page_link):
        self._opener(page_link)
        self._compute_crawl_delay()
        original_page = self._browser.parsed

        attacks_file = io.open("sqli-cookie-error-based.txt", "r", encoding='UTF-8')
        parsed_url = parse.urlparse(page_link)

        for payload in attacks_file:

            cookie = {'uname': payload.strip()}
            self._browser.session.cookies.update(cookie)

            injected = parse.urlunparse(parsed_url)
            self.window.lblsqltot.setText("Pausing for " + str(round(self.delay, 2)) + " seconds...")
            # sleep(self.delay)
            self.tested.emit(self.count)
            self._opener(injected)
            self._compute_crawl_delay()
            if '200' in str(self._browser.response):
                response_page = self._browser.parsed
                exploited = (str(response_page).find('error in your SQL syntax') != -1) or (
                        str(response_page).find('error in your MySQL syntax') != -1)
                if exploited and (original_page != response_page) and (not self._is_listed(page_link)):
                    self.exploited[self.count] = {'url': page_link, 'type': "error-based-get(cookie)",
                                                  'payload': payload}
                    self.count += 1
                    return True
        return False

    def _bool_based_get(self, page_link):
        self._opener(page_link)
        self._compute_crawl_delay()
        self.window.lblsqltot.setText("Pausing for " + str(round(self.delay, 2)) + " seconds...")
        # sleep(self.delay)
        self.tested.emit(self.count)
        self._opener(page_link)
        self._compute_crawl_delay()

        if '200' in str(self._browser.response):
            firstRsp = str(self._browser.parsed)
        else:
            return False

        attacks_file = io.open("sqli-bool-based.txt", "r")
        parsed_url = parse.urlparse(page_link)
        query_params = parsed_url.query.split("&")

        for row in attacks_file:
            payloads = row.split("_____")
            payload1 = payloads[0]
            new_query = '&'.join(["{}{}".format(param, payload1) for param in query_params])
            #  replace old query values with injection values
            parsed_url = parsed_url._replace(query=new_query)
            #  add new generated url to list of injected urls
            injected = parse.urlunparse(parsed_url)
            self.window.lblsqltot.setText("Pausing for " + str(round(self.delay, 2)) + " seconds...");
            # sleep(self.delay)
            self.tested.emit(self.count)
            self._opener(injected)
            self._compute_crawl_delay()
            if '200' in str(self._browser.response):
                secRsp = str(self._browser.parsed)

            payload2 = payloads[1].strip("\n")
            new_query = '&'.join(["{}{}".format(param, payload2) for param in query_params])
            #  replace old query values with injection values
            parsed_url = parsed_url._replace(query=new_query)
            #  add new generated url to list of injected urls
            injected = parse.urlunparse(parsed_url)
            self.window.lblsqltot.setText("Pausing for " + str(round(self.delay, 2)) + " seconds...");
            # sleep(self.delay)
            self.tested.emit(self.count)
            self._opener(injected)
            self._compute_crawl_delay()
            if '200' in str(self._browser.response):
                thirdRsp = str(self._browser.parsed)
                exploited = False
                if thirdRsp == firstRsp and secRsp != thirdRsp:
                    exploited = True
                if exploited and (not self._is_listed(page_link)):
                    self.exploited[self.count] = {'url': page_link, 'type': "bool-based-get",
                                                  'payload': row}
                    self.count += 1
                    return True
        return False

    def _handle_forms(self, page_link):
        self.window.lblsqltot.setText("Pausing for " + str(self.delay) + " seconds...");
        # sleep(self.delay)
        self.tested.emit(self.count)
        self._opener(page_link)
        self._compute_crawl_delay()
        forms = self._browser.get_forms()
        for form in forms:
            # if not self._is_form_tested(form, page_link, 'error-based'):
            if True:
                fields = FormHandler(self._browser)  # type FormHandler
                successful = fields.parser(form)
                if successful:
                    result = self._error_based_post(form, fields, page_link)
                    if result:
                        return
                else:
                    self.faults.append({'url': page_link, 'fault': fields.fault_type['fault']})
            else:
                continue
        for form in forms:
            # if not self._is_form_tested(form, page_link, 'time-based'):
            if True:
                fields = FormHandler(self._browser)  # type FormHandler
                successful = fields.parser(form)
                if successful:
                    result = self._time_based_post(form, fields, page_link)
                    if result:
                        return
                else:
                    self.faults.append({'url': page_link, 'fault': fields.fault_type['fault']})
            else:
                continue

        # for form in forms:
        #     # if not self._is_form_tested(form, page_link, 'error-based'):
        #     if True:
        #         fields = FormHandler(self._browser)  # type FormHandler
        #         successful = fields.parser(form)
        #         if successful:
        #             # result = True
        #             result = self._error_based_post_Http_header(form, fields, page_link)
        #             self._browser.session.headers[
        #                 'User-Agent'] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36"
        #             self._browser.session.headers['Referer'] = ""
        #             if result:
        #                 return
        #         else:
        #             self.faults.append({'url': page_link, 'fault': fields.fault_type['fault']})
        #     else:
        #         continue

    def _handle_forms_second(self, page_link):
        self.window.lblsqltot.setText("Pausing for " + str(self.delay) + " seconds...");
        # sleep(self.delay)
        self.tested.emit(self.count)
        self._opener(page_link)
        self._compute_crawl_delay()
        forms = self._browser.get_forms()
        for form in forms:
            # if not self._is_form_tested(form, page_link, 'error-based'):
            if True:
                fields = FormHandler(self._browser)  # type FormHandler
                successful = fields.parser(form)
                if successful:
                    result = self._second_post(form, fields, page_link)
                    self.second_order_url.append(page_link)
                    self.second_order_index += 1
                else:
                    self.faults.append({'url': page_link, 'fault': fields.fault_type['fault']})
            else:
                continue

    def run(self):
        start = datetime.now().time()
        while not self.finished:
            if self.running:
                # TODO
                for index in self._pages_to_exploit:
                    if self._pages_to_exploit[index]['from'] == self.info['login_url'] and not self._logged_in:
                        self._login()
                    for link in self._pages_to_exploit[index]['url'].keys():
                        print("post", link)
                        self._handle_forms_second(link)

                for url in self._dynamic_urls:
                    print("get", url)
                    self.current.emit(url)
                    self._handel_dynamics_second(url)
                    self.tested.emit(self.count)
                self.finished = True

        for index in self._pages_to_exploit:
            for link in self._pages_to_exploit[index]['url'].keys():
                print(link)
                self._opener(link)
                if '200' in str(self._browser.response):
                    secRsp = str(self._browser.parsed)
                    print(secRsp)
                    index1 = secRsp.find("sodA")
                    index2 = secRsp.find("sodB")
                    if index1 != -1 and index2 != -1:
                        print("get")
                        print(secRsp[index2 - 1])
                        secIndex = int(secRsp[index1 + 4:index2])
                        secUrl = self.second_order_url[secIndex]
                        print(secUrl)
                        if secUrl not in self.second_order.keys():
                            self.second_order[secUrl] = []

                        if link not in self.second_order[secUrl]:
                            self.second_order[secUrl].append(link)

        print(self.second_order)
        print(self.second_order_url)

        self.finished = False
        i = 0
        while not self.finished:
            if self.running:
                # TODO
                for index in self._pages_to_exploit:
                    if self._pages_to_exploit[index]['from'] == self.info['login_url'] and not self._logged_in:
                        self._login()
                    for link in self._pages_to_exploit[index]['url'].keys():
                        if link in self.second_order.keys():
                            print("post", link)
                            self.current.emit(link)
                            self._handle_forms(link)
                            found = False
                            if link in self._dynamic_urls:
                                for indexx in self.exploited:
                                    if link == self.exploited[indexx]['url']:
                                        found = True
                                        break
                                if found:
                                    self._dynamic_urls.remove(link)
                                    i += 1
                                    self.update_tsp.emit(i)
                                    self.tested.emit(self.count)
                                    break
                            else:
                                i += 1
                                self.update_tsp.emit(i)
                                self.tested.emit(self.count)

                for url in self._dynamic_urls:
                    if url in self.second_order.keys():
                        print("get", url)
                        self.current.emit(url)
                        self._handel_dynamics(url)
                        i += 1
                        self.update_tsp.emit(i)
                        self.tested.emit(self.count)

                self.finished = True

        self.finish.emit(self._wrap_up(start))

    def _calc_time(self, start):
        finish = datetime.now().time()
        delta1 = timedelta(seconds=start.second, microseconds=start.microsecond,
                           minutes=start.minute, hours=start.hour)
        delta2 = timedelta(seconds=finish.second, microseconds=finish.microsecond,
                           minutes=finish.minute, hours=finish.hour)
        taken = delta2 - delta1
        seconds = round(taken.total_seconds())
        if seconds >= 3600:
            hours = round(seconds / 3600)
            minutes = (round((seconds / 3600) / 60))
            elapsed = str(hours) + ':' + str(minutes) + ' hrs'
        elif seconds >= 60:
            minutes = round(seconds / 60)
            seconds = round(seconds % 60)
            elapsed = str(str(minutes) + '.' + str(seconds) + ' mins')
        else:
            elapsed = str(seconds) + ' secs'
        return elapsed

    def _wrap_up(self, start):
        wrap = {
            'exploited': self.exploited,
            'count': self.count,
            'faults': self.faults,
            'running': self.running,
            'time': self._calc_time(start)
        }
        return wrap
